package com.ringcentral.cassandra4io.cql

import com.datastax.oss.driver.api.core.`type`.UserDefinedType
import com.datastax.oss.driver.api.core.cql.BoundStatement
import com.datastax.oss.driver.api.core.data.UdtValue
import com.ringcentral.cassandra4io.cql.ToUdtValue.{ make, makeWithFieldName }

/**
 * A typeclass that is used to turn a Scala datatype into a UdtValue. Typeclass instances for FromUdtValue
 * are (inductively) derived from CassandraTypeMapper
 *
 * @tparam Scala is the Scala datatype that you intend to convert into a Cassandra UdtValue
 */
trait ToUdtValue[-Scala]      { self =>
  def convert(fieldName: FieldName, input: Scala, constructor: UdtValue): UdtValue

  def contramap[AnotherScala](f: AnotherScala => Scala): ToUdtValue[AnotherScala] =
    (fieldName: FieldName, input: AnotherScala, constructor: UdtValue) => self.convert(fieldName, f(input), constructor)
}
object ToUdtValue extends LowerPriorityToUdtValue with LowestPriorityToUdtValue {
  // represents a ToUdtValue whose UdtValue is fully set up
  // this can only be generated by the Shapeless machinery
  trait Object[-A] extends ToUdtValue[A]

  def deriveBinder[A](implicit ev: ToUdtValue.Object[A]): Binder[A] = {
    (statement: BoundStatement, index: Int, value: A) =>
      val constructor = statement.getType(index).asInstanceOf[UserDefinedType]
      val udtValue    = ev.convert(FieldName.Unused, value, constructor.newValue())
      (statement.setUdtValue(index, udtValue), index + 1)
  }

  // only allowed to summon fully built out ToUdtValue instances which are built by Shapeless machinery
  def apply[A](implicit ev: ToUdtValue.Object[A]): ToUdtValue.Object[A] = ev

  def make[A](mk: (A, UdtValue) => UdtValue): ToUdtValue[A] =
    (fieldName: FieldName, input: A, constructor: UdtValue) =>
      fieldName match {
        case FieldName.Unused =>
          mk(input, constructor)

        case FieldName.Labelled(value) =>
          throw new RuntimeException(s"ToUdtValue failure: Expected an unused fieldName for $input but got $value")
      }

  def makeWithFieldName[A](mk: (String, A, UdtValue) => UdtValue): ToUdtValue[A] =
    (fieldName: FieldName, input: A, constructor: UdtValue) =>
      fieldName match {
        case FieldName.Unused =>
          throw new RuntimeException(s"ToUdtValue failure: Expected a labelled fieldName for $input but got unused")

        case FieldName.Labelled(fieldName) =>
          mk(fieldName, input, constructor)
      }
}
trait LowerPriorityToUdtValue {

  implicit def deriveOption[A](implicit
    ev: ToUdtValue.Object[A]
  ): ToUdtValue[Option[A]] = make {
    case (Some(value), constructor) => ToUdtValue[A].convert(FieldName.Unused, value, constructor)
    case (_, constructor) => constructor
  }

  /**
   * ToUdtValue relies on the CassandraTypeMapper to convert Scala datatypes into datatypes compatible with the
   * Datastax Java driver (bi-directionally) in order to produce instances of FromUdtValue[A]. CassandraTypeMapper will
   * also inductively derive instances if you have nested data-types (collections within collections or collections
   * within UdtValues within collections or any combinations of these types) inside your UdtValue
   *
   * @param ev is evidence that we can materialize a CassandraTypeMapper for A
   * @tparam A is the Scala datatype that we would like to convert into the Datastax Java type
   * @return
   */
  implicit def deriveFromCassandraTypeMapper[A](implicit
    ev: CassandraTypeMapper[A]
  ): ToUdtValue[A] =
    makeWithFieldName[A] { (fieldName, input, constructor) =>
      constructor.set[ev.Cassandra](fieldName, ev.toCassandra(input, constructor.getType(fieldName)), ev.classType)
    }
}
